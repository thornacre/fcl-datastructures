/**\n * Scoring Algorithms for Legal Document Ranking\n * =============================================\n *\n * This module implements various scoring and ranking algorithms for legal documents\n * in Find Case Law (FCL). Provides sophisticated relevance scoring, citation analysis,\n * and multi-factor ranking for search results and document recommendations.\n *\n * Key FCL Use Cases:\n * - Relevance scoring for search results ranking\n * - Citation network analysis and authority scoring\n * - Document similarity computation for recommendations\n * - Legal precedent strength evaluation\n * - Multi-criteria decision making for document selection\n */\n\n/**\n * Represents a legal document with scoring metadata\n */\nclass LegalDocument {\n    constructor(id, title, content, metadata = {}) {\n        this.id = id;\n        this.title = title;\n        this.content = content;\n        this.metadata = {\n            court: null,\n            date: null,\n            citation: null,\n            wordCount: 0,\n            ...metadata\n        };\n        this.scores = {\n            relevance: 0.0,\n            authority: 0.0,\n            recency: 0.0,\n            similarity: 0.0,\n            combined: 0.0\n        };\n        this.citations = {\n            incoming: [],\n            outgoing: []\n        };\n    }\n\n    toString() {\n        return `${this.metadata.citation || this.id}: ${this.title}`;\n    }\n}\n\n/**\n * TF-IDF (Term Frequency-Inverse Document Frequency) scoring implementation\n */\nclass TfIdfScorer {\n    constructor(documents) {\n        this.documents = documents;\n        this.documentCount = documents.length;\n        this.termDocumentFreq = new Map(); // term -> number of documents containing term\n        this.documentTermFreq = new Map(); // docId -> Map(term -> frequency)\n        this.idfCache = new Map();\n\n        this._buildIndex();\n    }\n\n    /**\n     * Calculate TF-IDF score for a document given query terms\n     * @param {string} docId - Document ID\n     * @param {string[]} queryTerms - Query terms\n     * @returns {number} TF-IDF score\n     */\n    calculateScore(docId, queryTerms) {\n        let totalScore = 0.0;\n        const docTerms = this.documentTermFreq.get(docId);\n        \n        if (!docTerms) {\n            return 0.0;\n        }\n\n        const docLength = Array.from(docTerms.values())\n            .reduce((sum, freq) => sum + freq, 0);\n\n        for (const term of queryTerms) {\n            const termFreq = docTerms.get(term) || 0;\n            if (termFreq > 0) {\n                const tf = termFreq / docLength; // Normalized term frequency\n                const idf = this._getIdf(term);\n                totalScore += tf * idf;\n            }\n        }\n\n        return totalScore;\n    }\n\n    /**\n     * Calculate TF-IDF vectors for all documents\n     * @returns {Map} Document ID -> TF-IDF vector\n     */\n    calculateTfIdfVectors() {\n        const vectors = new Map();\n        const allTerms = Array.from(this.termDocumentFreq.keys());\n\n        for (const doc of this.documents) {\n            const vector = new Map();\n            const docTerms = this.documentTermFreq.get(doc.id);\n            \n            if (docTerms) {\n                const docLength = Array.from(docTerms.values())\n                    .reduce((sum, freq) => sum + freq, 0);\n\n                for (const term of allTerms) {\n                    const termFreq = docTerms.get(term) || 0;\n                    const tf = docLength > 0 ? termFreq / docLength : 0;\n                    const idf = this._getIdf(term);\n                    vector.set(term, tf * idf);\n                }\n            }\n            \n            vectors.set(doc.id, vector);\n        }\n\n        return vectors;\n    }\n\n    /**\n     * Build inverted index for TF-IDF calculation\n     */\n    _buildIndex() {\n        // Initialize maps\n        this.termDocumentFreq.clear();\n        this.documentTermFreq.clear();\n\n        for (const doc of this.documents) {\n            const terms = this._tokenize(doc.content);\n            const termFreq = new Map();\n\n            // Count term frequencies in document\n            for (const term of terms) {\n                termFreq.set(term, (termFreq.get(term) || 0) + 1);\n            }\n\n            this.documentTermFreq.set(doc.id, termFreq);\n\n            // Update document frequencies\n            for (const term of termFreq.keys()) {\n                this.termDocumentFreq.set(term, \n                    (this.termDocumentFreq.get(term) || 0) + 1);\n            }\n        }\n    }\n\n    /**\n     * Get or calculate IDF for a term\n     * @param {string} term - Term to calculate IDF for\n     * @returns {number} IDF value\n     */\n    _getIdf(term) {\n        if (this.idfCache.has(term)) {\n            return this.idfCache.get(term);\n        }\n\n        const docFreq = this.termDocumentFreq.get(term) || 0;\n        const idf = docFreq > 0 ? Math.log(this.documentCount / docFreq) : 0;\n        this.idfCache.set(term, idf);\n        return idf;\n    }\n\n    /**\n     * Tokenize text for TF-IDF calculation\n     * @param {string} text - Text to tokenize\n     * @returns {string[]} Array of tokens\n     */\n    _tokenize(text) {\n        return text.toLowerCase()\n            .replace(/[^a-zA-Z0-9\\s]/g, ' ')\n            .split(/\\s+/)\n            .filter(token => token.length > 2);\n    }\n}\n\n/**\n * PageRank-style algorithm for legal document authority scoring\n */\nclass LegalAuthorityScorer {\n    constructor(documents, dampingFactor = 0.85, maxIterations = 50, tolerance = 1e-6) {\n        this.documents = documents;\n        this.dampingFactor = dampingFactor;\n        this.maxIterations = maxIterations;\n        this.tolerance = tolerance;\n        this.documentMap = new Map(documents.map(doc => [doc.id, doc]));\n        this.authorityScores = new Map();\n        \n        this._buildCitationGraph();\n    }\n\n    /**\n     * Calculate authority scores using PageRank algorithm\n     * @returns {Map} Document ID -> authority score\n     */\n    calculateAuthorityScores() {\n        const n = this.documents.length;\n        const initialScore = 1.0 / n;\n        \n        // Initialize scores\n        this.authorityScores.clear();\n        for (const doc of this.documents) {\n            this.authorityScores.set(doc.id, initialScore);\n        }\n\n        // Iterative calculation\n        for (let iteration = 0; iteration < this.maxIterations; iteration++) {\n            const newScores = new Map();\n            let maxDelta = 0;\n\n            for (const doc of this.documents) {\n                let score = (1 - this.dampingFactor) / n;\n                \n                // Add contributions from citing documents\n                for (const citingDocId of doc.citations.incoming) {\n                    const citingDoc = this.documentMap.get(citingDocId);\n                    if (citingDoc) {\n                        const citingScore = this.authorityScores.get(citingDocId) || initialScore;\n                        const outgoingCount = citingDoc.citations.outgoing.length || 1;\n                        score += this.dampingFactor * (citingScore / outgoingCount);\n                    }\n                }\n\n                newScores.set(doc.id, score);\n                \n                // Track convergence\n                const oldScore = this.authorityScores.get(doc.id) || initialScore;\n                maxDelta = Math.max(maxDelta, Math.abs(score - oldScore));\n            }\n\n            this.authorityScores = newScores;\n\n            // Check convergence\n            if (maxDelta < this.tolerance) {\n                console.log(`Authority scoring converged after ${iteration + 1} iterations`);\n                break;\n            }\n        }\n\n        return this.authorityScores;\n    }\n\n    /**\n     * Calculate HITS (Hyperlink-Induced Topic Search) scores\n     * @returns {Object} Object with authority and hub scores\n     */\n    calculateHitsScores() {\n        const n = this.documents.length;\n        const authorityScores = new Map();\n        const hubScores = new Map();\n\n        // Initialize scores\n        for (const doc of this.documents) {\n            authorityScores.set(doc.id, 1.0);\n            hubScores.set(doc.id, 1.0);\n        }\n\n        // Iterative calculation\n        for (let iteration = 0; iteration < this.maxIterations; iteration++) {\n            const newAuthorityScores = new Map();\n            const newHubScores = new Map();\n\n            // Update authority scores\n            for (const doc of this.documents) {\n                let authorityScore = 0;\n                for (const citingDocId of doc.citations.incoming) {\n                    authorityScore += hubScores.get(citingDocId) || 0;\n                }\n                newAuthorityScores.set(doc.id, authorityScore);\n            }\n\n            // Update hub scores\n            for (const doc of this.documents) {\n                let hubScore = 0;\n                for (const citedDocId of doc.citations.outgoing) {\n                    hubScore += authorityScores.get(citedDocId) || 0;\n                }\n                newHubScores.set(doc.id, hubScore);\n            }\n\n            // Normalize scores\n            this._normalizeScores(newAuthorityScores);\n            this._normalizeScores(newHubScores);\n\n            // Check convergence\n            let converged = true;\n            for (const docId of authorityScores.keys()) {\n                const authDelta = Math.abs((newAuthorityScores.get(docId) || 0) - (authorityScores.get(docId) || 0));\n                const hubDelta = Math.abs((newHubScores.get(docId) || 0) - (hubScores.get(docId) || 0));\n                if (authDelta > this.tolerance || hubDelta > this.tolerance) {\n                    converged = false;\n                    break;\n                }\n            }\n\n            authorityScores.clear();\n            hubScores.clear();\n            newAuthorityScores.forEach((score, docId) => authorityScores.set(docId, score));\n            newHubScores.forEach((score, docId) => hubScores.set(docId, score));\n\n            if (converged) {\n                console.log(`HITS algorithm converged after ${iteration + 1} iterations`);\n                break;\n            }\n        }\n\n        return { authority: authorityScores, hub: hubScores };\n    }\n\n    /**\n     * Build citation graph from document citations\n     */\n    _buildCitationGraph() {\n        // Initialize citation arrays\n        for (const doc of this.documents) {\n            if (!doc.citations.incoming) doc.citations.incoming = [];\n            if (!doc.citations.outgoing) doc.citations.outgoing = [];\n        }\n    }\n\n    /**\n     * Normalize scores to unit vector\n     * @param {Map} scores - Score map to normalize\n     */\n    _normalizeScores(scores) {\n        const sumSquares = Array.from(scores.values())\n            .reduce((sum, score) => sum + score * score, 0);\n        const norm = Math.sqrt(sumSquares);\n        \n        if (norm > 0) {\n            for (const [docId, score] of scores.entries()) {\n                scores.set(docId, score / norm);\n            }\n        }\n    }\n}\n\n/**\n * Cosine similarity calculator for document similarity\n */\nclass CosineSimilarityCalculator {\n    /**\n     * Calculate cosine similarity between two TF-IDF vectors\n     * @param {Map} vectorA - First TF-IDF vector\n     * @param {Map} vectorB - Second TF-IDF vector\n     * @returns {number} Cosine similarity (0-1)\n     */\n    static calculateSimilarity(vectorA, vectorB) {\n        const allTerms = new Set([...vectorA.keys(), ...vectorB.keys()]);\n        \n        let dotProduct = 0;\n        let normA = 0;\n        let normB = 0;\n\n        for (const term of allTerms) {\n            const weightA = vectorA.get(term) || 0;\n            const weightB = vectorB.get(term) || 0;\n            \n            dotProduct += weightA * weightB;\n            normA += weightA * weightA;\n            normB += weightB * weightB;\n        }\n\n        const denominator = Math.sqrt(normA) * Math.sqrt(normB);\n        return denominator > 0 ? dotProduct / denominator : 0;\n    }\n\n    /**\n     * Find most similar documents to a given document\n     * @param {string} targetDocId - Target document ID\n     * @param {Map} tfIdfVectors - TF-IDF vectors for all documents\n     * @param {number} topK - Number of similar documents to return\n     * @returns {Array} Array of {docId, similarity} objects\n     */\n    static findSimilarDocuments(targetDocId, tfIdfVectors, topK = 10) {\n        const targetVector = tfIdfVectors.get(targetDocId);\n        if (!targetVector) {\n            return [];\n        }\n\n        const similarities = [];\n        for (const [docId, vector] of tfIdfVectors.entries()) {\n            if (docId !== targetDocId) {\n                const similarity = this.calculateSimilarity(targetVector, vector);\n                similarities.push({ docId, similarity });\n            }\n        }\n\n        return similarities\n            .sort((a, b) => b.similarity - a.similarity)\n            .slice(0, topK);\n    }\n}\n\n/**\n * Recency scorer for temporal relevance\n */\nclass RecencyScorer {\n    /**\n     * Calculate recency score based on document date\n     * @param {Date} documentDate - Document publication date\n     * @param {Date} referenceDate - Reference date (default: now)\n     * @param {number} halfLife - Half-life in days for exponential decay\n     * @returns {number} Recency score (0-1)\n     */\n    static calculateRecencyScore(documentDate, referenceDate = new Date(), halfLife = 365) {\n        const daysDiff = (referenceDate - documentDate) / (1000 * 60 * 60 * 24);\n        const decayConstant = Math.log(2) / halfLife;\n        return Math.exp(-decayConstant * Math.max(0, daysDiff));\n    }\n\n    /**\n     * Calculate temporal relevance with different decay functions\n     * @param {Date} documentDate - Document date\n     * @param {string} decayType - Type of decay ('exponential', 'linear', 'logarithmic')\n     * @param {Object} params - Decay parameters\n     * @returns {number} Temporal relevance score\n     */\n    static calculateTemporalRelevance(documentDate, decayType = 'exponential', params = {}) {\n        const referenceDate = params.referenceDate || new Date();\n        const daysDiff = (referenceDate - documentDate) / (1000 * 60 * 60 * 24);\n        \n        switch (decayType) {\n            case 'exponential':\n                const halfLife = params.halfLife || 365;\n                const decayConstant = Math.log(2) / halfLife;\n                return Math.exp(-decayConstant * Math.max(0, daysDiff));\n                \n            case 'linear':\n                const maxDays = params.maxDays || 1095; // 3 years\n                return Math.max(0, 1 - (daysDiff / maxDays));\n                \n            case 'logarithmic':\n                const scaleFactor = params.scaleFactor || 100;\n                return daysDiff <= 0 ? 1 : 1 / (1 + Math.log(1 + daysDiff / scaleFactor));\n                \n            default:\n                return this.calculateRecencyScore(documentDate, referenceDate);\n        }\n    }\n}\n\n/**\n * Multi-criteria scoring system combining various relevance factors\n */\nclass MultiCriteriaScorer {\n    constructor(weights = {}) {\n        this.weights = {\n            relevance: 0.4,\n            authority: 0.3,\n            recency: 0.2,\n            similarity: 0.1,\n            ...weights\n        };\n        \n        // Normalize weights\n        const totalWeight = Object.values(this.weights).reduce((sum, w) => sum + w, 0);\n        if (totalWeight > 0) {\n            Object.keys(this.weights).forEach(key => {\n                this.weights[key] /= totalWeight;\n            });\n        }\n    }\n\n    /**\n     * Calculate combined score for a document\n     * @param {Object} scores - Individual score components\n     * @returns {number} Combined score\n     */\n    calculateCombinedScore(scores) {\n        let combinedScore = 0;\n        \n        for (const [factor, weight] of Object.entries(this.weights)) {\n            if (scores[factor] !== undefined) {\n                combinedScore += weight * scores[factor];\n            }\n        }\n        \n        return combinedScore;\n    }\n\n    /**\n     * Rank documents using multi-criteria scoring\n     * @param {LegalDocument[]} documents - Documents to rank\n     * @param {string[]} queryTerms - Query terms for relevance scoring\n     * @param {Object} options - Ranking options\n     * @returns {Array} Ranked documents with scores\n     */\n    rankDocuments(documents, queryTerms = [], options = {}) {\n        const rankedDocs = [];\n        \n        // Initialize scorers\n        const tfIdfScorer = new TfIdfScorer(documents);\n        const authorityScorer = new LegalAuthorityScorer(documents);\n        \n        // Calculate authority scores\n        const authorityScores = authorityScorer.calculateAuthorityScores();\n        \n        // Calculate TF-IDF vectors for similarity\n        const tfIdfVectors = tfIdfScorer.calculateTfIdfVectors();\n        \n        for (const doc of documents) {\n            const scores = {\n                relevance: queryTerms.length > 0 ? \n                    tfIdfScorer.calculateScore(doc.id, queryTerms) : 0,\n                authority: authorityScores.get(doc.id) || 0,\n                recency: doc.metadata.date ? \n                    RecencyScorer.calculateRecencyScore(doc.metadata.date) : 0,\n                similarity: 0 // Will be calculated if needed\n            };\n            \n            // Calculate similarity to reference document if specified\n            if (options.referenceDocId && tfIdfVectors.has(options.referenceDocId)) {\n                const targetVector = tfIdfVectors.get(doc.id);\n                const refVector = tfIdfVectors.get(options.referenceDocId);\n                scores.similarity = CosineSimilarityCalculator.calculateSimilarity(\n                    targetVector, refVector\n                );\n            }\n            \n            // Calculate combined score\n            const combinedScore = this.calculateCombinedScore(scores);\n            \n            rankedDocs.push({\n                document: doc,\n                scores: { ...scores, combined: combinedScore }\n            });\n        }\n        \n        // Sort by combined score\n        return rankedDocs.sort((a, b) => b.scores.combined - a.scores.combined);\n    }\n}\n\n/**\n * Legal precedent strength calculator\n */\nclass PrecedentStrengthCalculator {\n    /**\n     * Calculate precedent strength based on multiple factors\n     * @param {LegalDocument} precedent - Precedent case document\n     * @param {LegalDocument} currentCase - Current case document\n     * @param {Object} factors - Strength calculation factors\n     * @returns {number} Precedent strength score (0-1)\n     */\n    static calculatePrecedentStrength(precedent, currentCase, factors = {}) {\n        const {\n            courtHierarchyWeight = 0.4,\n            factualSimilarityWeight = 0.3,\n            temporalRelevanceWeight = 0.2,\n            citationFrequencyWeight = 0.1\n        } = factors;\n        \n        // Court hierarchy score\n        const hierarchyScore = this._calculateCourtHierarchyScore(\n            precedent.metadata.court, \n            currentCase.metadata.court\n        );\n        \n        // Factual similarity (simplified - would use NLP in practice)\n        const factualScore = this._calculateFactualSimilarity(\n            precedent.content, \n            currentCase.content\n        );\n        \n        // Temporal relevance\n        const temporalScore = precedent.metadata.date ? \n            RecencyScorer.calculateRecencyScore(precedent.metadata.date) : 0;\n        \n        // Citation frequency (authority)\n        const citationScore = this._calculateCitationScore(precedent);\n        \n        return (\n            courtHierarchyWeight * hierarchyScore +\n            factualSimilarityWeight * factualScore +\n            temporalRelevanceWeight * temporalScore +\n            citationFrequencyWeight * citationScore\n        );\n    }\n    \n    /**\n     * Calculate court hierarchy score\n     * @param {string} precedentCourt - Precedent court code\n     * @param {string} currentCourt - Current court code\n     * @returns {number} Hierarchy score\n     */\n    static _calculateCourtHierarchyScore(precedentCourt, currentCourt) {\n        const courtLevels = {\n            'UKSC': 5, // Supreme Court\n            'UKHL': 5, // House of Lords\n            'EWCA': 4, // Court of Appeal\n            'EWHC': 3, // High Court\n            'UKUT': 2, // Upper Tribunal\n            'UKFTT': 1 // First-tier Tribunal\n        };\n        \n        const precedentLevel = courtLevels[precedentCourt] || 1;\n        const currentLevel = courtLevels[currentCourt] || 1;\n        \n        // Higher or equal court decisions are more binding\n        if (precedentLevel >= currentLevel) {\n            return precedentLevel / 5; // Normalize to 0-1\n        } else {\n            return (precedentLevel / 5) * 0.5; // Reduced weight for lower courts\n        }\n    }\n    \n    /**\n     * Calculate factual similarity (simplified)\n     * @param {string} precedentContent - Precedent case content\n     * @param {string} currentContent - Current case content\n     * @returns {number} Factual similarity score\n     */\n    static _calculateFactualSimilarity(precedentContent, currentContent) {\n        // Simplified similarity calculation\n        const precedentTerms = new Set(precedentContent.toLowerCase().split(/\\s+/));\n        const currentTerms = new Set(currentContent.toLowerCase().split(/\\s+/));\n        \n        const intersection = new Set(\n            [...precedentTerms].filter(term => currentTerms.has(term))\n        );\n        const union = new Set([...precedentTerms, ...currentTerms]);\n        \n        return union.size > 0 ? intersection.size / union.size : 0;\n    }\n    \n    /**\n     * Calculate citation score based on incoming citations\n     * @param {LegalDocument} document - Document to score\n     * @returns {number} Citation score\n     */\n    static _calculateCitationScore(document) {\n        const incomingCitations = document.citations.incoming.length;\n        // Logarithmic scaling to prevent over-weighting highly cited cases\n        return incomingCitations > 0 ? Math.log(1 + incomingCitations) / Math.log(100) : 0;\n    }\n}\n\n/**\n * Demonstrate scoring algorithms with UK legal documents\n */\nfunction demonstrateScoringAlgorithms() {\n    console.log('=== Scoring Algorithms for Legal Documents Demo ===\\n');\n    \n    // Create sample legal documents\n    const documents = [\n        new LegalDocument(\n            'uksc_2023_15',\n            'R (Miller) v Prime Minister',\n            'This Supreme Court case concerns constitutional law and parliamentary sovereignty. The principles of separation of powers and judicial review are fundamental to our constitutional framework.',\n            {\n                court: 'UKSC',\n                date: new Date('2023-05-15'),\n                citation: '[2023] UKSC 15',\n                wordCount: 12500\n            }\n        ),\n        new LegalDocument(\n            'ewca_2023_892',\n            'Smith v Secretary of State',\n            'The Court of Appeal considered administrative law principles and judicial review procedures. The Wednesbury test applies to decisions of public bodies and constitutional principles.',\n            {\n                court: 'EWCA',\n                date: new Date('2023-08-22'),\n                citation: '[2023] EWCA Civ 892',\n                wordCount: 8900\n            }\n        ),\n        new LegalDocument(\n            'ewhc_2023_1456',\n            'Jones v Local Authority',\n            'This High Court case examined human rights principles and procedural fairness. Administrative law requires compliance with constitutional standards.',\n            {\n                court: 'EWHC',\n                date: new Date('2023-06-30'),\n                citation: '[2023] EWHC 1456 (Admin)',\n                wordCount: 6700\n            }\n        )\n    ];\n    \n    // Set up citation relationships\n    documents[1].citations.outgoing = ['uksc_2023_15']; // EWCA cites UKSC\n    documents[0].citations.incoming = ['ewca_2023_892'];\n    documents[2].citations.outgoing = ['uksc_2023_15'];\n    documents[0].citations.incoming.push('ewhc_2023_1456');\n    \n    // 1. TF-IDF Scoring\n    console.log('1. TF-IDF RELEVANCE SCORING:');\n    const tfIdfScorer = new TfIdfScorer(documents);\n    const queryTerms = ['constitutional', 'law', 'principles'];\n    \n    console.log(`   Query: \"${queryTerms.join(' ')}\"`); \n    for (const doc of documents) {\n        const score = tfIdfScorer.calculateScore(doc.id, queryTerms);\n        console.log(`   ${doc.metadata.citation}: ${score.toFixed(4)}`);\n    }\n    \n    // 2. Authority Scoring (PageRank)\n    console.log('\\n2. LEGAL AUTHORITY SCORING (PageRank):');\n    const authorityScorer = new LegalAuthorityScorer(documents);\n    const authorityScores = authorityScorer.calculateAuthorityScores();\n    \n    console.log('   Authority scores:');\n    const sortedByAuthority = [...authorityScores.entries()]\n        .sort((a, b) => b[1] - a[1]);\n    for (const [docId, score] of sortedByAuthority) {\n        const doc = documents.find(d => d.id === docId);\n        console.log(`   ${doc.metadata.citation}: ${score.toFixed(4)}`);\n    }\n    \n    // 3. HITS Algorithm\n    console.log('\\n3. HITS ALGORITHM (Authority & Hub Scores):');\n    const hitsScores = authorityScorer.calculateHitsScores();\n    \n    console.log('   HITS Authority scores:');\n    for (const [docId, score] of hitsScores.authority.entries()) {\n        const doc = documents.find(d => d.id === docId);\n        console.log(`   ${doc.metadata.citation}: ${score.toFixed(4)}`);\n    }\n    \n    // 4. Document Similarity\n    console.log('\\n4. DOCUMENT SIMILARITY (Cosine Similarity):');\n    const tfIdfVectors = tfIdfScorer.calculateTfIdfVectors();\n    const similarDocs = CosineSimilarityCalculator.findSimilarDocuments(\n        'uksc_2023_15', tfIdfVectors, 2\n    );\n    \n    console.log('   Documents similar to UKSC 2023/15:');\n    for (const {docId, similarity} of similarDocs) {\n        const doc = documents.find(d => d.id === docId);\n        console.log(`   ${doc.metadata.citation}: ${similarity.toFixed(4)}`);\n    }\n    \n    // 5. Recency Scoring\n    console.log('\\n5. RECENCY SCORING:');\n    console.log('   Recency scores (exponential decay):');\n    for (const doc of documents) {\n        const recencyScore = RecencyScorer.calculateRecencyScore(doc.metadata.date);\n        console.log(`   ${doc.metadata.citation}: ${recencyScore.toFixed(4)}`);\n    }\n    \n    // 6. Multi-Criteria Ranking\n    console.log('\\n6. MULTI-CRITERIA RANKING:');\n    const multiScorer = new MultiCriteriaScorer({\n        relevance: 0.4,\n        authority: 0.3,\n        recency: 0.2,\n        similarity: 0.1\n    });\n    \n    const rankedDocs = multiScorer.rankDocuments(documents, queryTerms);\n    \n    console.log('   Combined ranking:');\n    for (const {document, scores} of rankedDocs) {\n        console.log(`   ${document.metadata.citation}: ${scores.combined.toFixed(4)}`);\n        console.log(`     Relevance: ${scores.relevance.toFixed(3)}, ` +\n                   `Authority: ${scores.authority.toFixed(3)}, ` +\n                   `Recency: ${scores.recency.toFixed(3)}`);\n    }\n    \n    // 7. Precedent Strength\n    console.log('\\n7. PRECEDENT STRENGTH ANALYSIS:');\n    const precedent = documents[0]; // UKSC case\n    const currentCase = documents[1]; // EWCA case\n    \n    const precedentStrength = PrecedentStrengthCalculator.calculatePrecedentStrength(\n        precedent, currentCase\n    );\n    \n    console.log(`   Precedent strength of ${precedent.metadata.citation} ` +\n               `for ${currentCase.metadata.citation}: ${precedentStrength.toFixed(4)}`);\n    \n    // 8. Performance Summary\n    console.log('\\n8. ALGORITHM PERFORMANCE SUMMARY:');\n    console.log('    TF-IDF: Fast relevance scoring, good for keyword matching');\n    console.log('    PageRank: Authority ranking based on citation network');\n    console.log('    HITS: Distinguishes authorities from good citation sources');\n    console.log('    Cosine Similarity: Content-based similarity matching');\n    console.log('    Recency Scoring: Temporal relevance with configurable decay');\n    console.log('    Multi-Criteria: Combines multiple factors for comprehensive ranking');\n    console.log('    Precedent Strength: Legal-specific binding force calculation');\n    \n    return {\n        documents,\n        scores: {\n            tfIdf: Object.fromEntries(\n                documents.map(doc => [doc.id, tfIdfScorer.calculateScore(doc.id, queryTerms)])\n            ),\n            authority: Object.fromEntries(authorityScores),\n            hits: hitsScores,\n            similarity: similarDocs,\n            ranking: rankedDocs\n        }\n    };\n}\n\n// Export classes and functions for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = {\n        LegalDocument,\n        TfIdfScorer,\n        LegalAuthorityScorer,\n        CosineSimilarityCalculator,\n        RecencyScorer,\n        MultiCriteriaScorer,\n        PrecedentStrengthCalculator,\n        demonstrateScoringAlgorithms\n    };\n}\n\n// Run demonstration if this file is executed directly\nif (typeof require !== 'undefined' && require.main === module) {\n    demonstrateScoringAlgorithms();\n}"