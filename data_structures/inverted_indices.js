/**\n * Inverted Indices for Full-Text Search\n * =====================================\n *\n * This module implements inverted indices for full-text search functionality\n * in Find Case Law (FCL). Provides efficient text search capabilities for\n * large collections of legal documents.\n *\n * Key FCL Use Cases:\n * - Fast full-text search across judgment collections\n * - Boolean query processing (AND, OR, NOT)\n * - Phrase search and proximity queries\n * - Relevance scoring and ranking\n * - Auto-completion and suggestion features\n */\n\n/**\n * Represents a single entry in a posting list\n */\nclass PostingListEntry {\n    constructor(documentId, termFrequency, positions, normalizedFrequency = 0.0) {\n        this.documentId = documentId;\n        this.termFrequency = termFrequency;\n        this.positions = positions;\n        this.normalizedFrequency = normalizedFrequency;\n    }\n}\n\n/**\n * Represents a search result with scoring information\n */\nclass SearchResult {\n    constructor(documentId, score, matchedTerms, snippet) {\n        this.documentId = documentId;\n        this.score = score;\n        this.matchedTerms = matchedTerms;\n        this.snippet = snippet;\n    }\n}\n\n/**\n * High-performance inverted index implementation for legal document search.\n */\nclass InvertedIndex {\n    constructor() {\n        // Core index structures\n        this.termIndex = new Map(); // term -> PostingListEntry[]\n        this.documentFrequencies = new Map(); // term -> document count\n        this.documents = new Map(); // docId -> document data\n        this.totalDocuments = 0;\n\n        // Search optimization\n        this.stopwords = new Set([\n            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to',\n            'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be',\n            'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',\n            'will', 'would', 'could', 'should', 'may', 'might', 'can'\n        ]);\n\n        // Legal-specific boosts\n        this.courtWeights = {\n            'UKSC': 2.0,    // Supreme Court\n            'UKHL': 1.8,    // House of Lords\n            'EWCA': 1.6,    // Court of Appeal\n            'EWHC': 1.4,    // High Court\n            'UKUT': 1.2,    // Upper Tribunal\n            'UKFTT': 1.0,   // First-tier Tribunal\n        };\n    }\n\n    /**\n     * Add a document to the index.\n     * @param {string} docId - Document identifier\n     * @param {string} content - Document content\n     * @param {Object} metadata - Document metadata\n     */\n    addDocument(docId, content, metadata = {}) {\n        if (this.documents.has(docId)) {\n            this.removeDocument(docId);\n        }\n\n        // Store document metadata\n        this.documents.set(docId, {\n            content,\n            metadata,\n            indexedAt: new Date().toISOString(),\n            length: content.split(/\\s+/).length\n        });\n\n        // Tokenize and index\n        const tokens = this._tokenize(content);\n        const termPositions = new Map();\n        const termFrequencies = new Map();\n\n        // Build term positions and frequencies\n        tokens.forEach((token, position) => {\n            if (!this.stopwords.has(token) && token.length > 2) {\n                if (!termPositions.has(token)) {\n                    termPositions.set(token, []);\n                }\n                termPositions.get(token).push(position);\n\n                termFrequencies.set(token, (termFrequencies.get(token) || 0) + 1);\n            }\n        });\n\n        // Add to inverted index\n        termFrequencies.forEach((frequency, term) => {\n            // Calculate normalized frequency (TF component)\n            const normalizedFreq = tokens.length > 0 ? frequency / tokens.length : 0;\n\n            const posting = new PostingListEntry(\n                docId,\n                frequency,\n                termPositions.get(term) || [],\n                normalizedFreq\n            );\n\n            if (!this.termIndex.has(term)) {\n                this.termIndex.set(term, []);\n            }\n            this.termIndex.get(term).push(posting);\n\n            this.documentFrequencies.set(term, (this.documentFrequencies.get(term) || 0) + 1);\n        });\n\n        this.totalDocuments++;\n    }\n\n    /**\n     * Remove a document from the index.\n     * @param {string} docId - Document identifier\n     * @returns {boolean} True if document was removed\n     */\n    removeDocument(docId) {\n        if (!this.documents.has(docId)) {\n            return false;\n        }\n\n        // Remove from posting lists\n        const termsToRemove = [];\n        for (const [term, postings] of this.termIndex.entries()) {\n            const originalLength = postings.length;\n            const filtered = postings.filter(p => p.documentId !== docId);\n            this.termIndex.set(term, filtered);\n\n            // Update document frequency\n            if (filtered.length < originalLength) {\n                const newDocFreq = (this.documentFrequencies.get(term) || 1) - 1;\n                if (newDocFreq > 0) {\n                    this.documentFrequencies.set(term, newDocFreq);\n                } else {\n                    this.documentFrequencies.delete(term);\n                }\n            }\n\n            // Mark empty terms for removal\n            if (filtered.length === 0) {\n                termsToRemove.push(term);\n            }\n        }\n\n        // Remove empty terms\n        termsToRemove.forEach(term => {\n            this.termIndex.delete(term);\n            this.documentFrequencies.delete(term);\n        });\n\n        // Remove document metadata\n        this.documents.delete(docId);\n        this.totalDocuments--;\n        return true;\n    }\n\n    /**\n     * Perform full-text search with TF-IDF scoring.\n     * @param {string} query - Search query\n     * @param {number} maxResults - Maximum results to return\n     * @param {Object} filters - Additional filters\n     * @returns {SearchResult[]} Array of search results\n     */\n    search(query, maxResults = 20, filters = {}) {\n        // Parse and tokenize query\n        let queryTerms = this._tokenize(query.toLowerCase());\n        queryTerms = queryTerms.filter(term => !this.stopwords.has(term) && term.length > 2);\n\n        if (queryTerms.length === 0) {\n            return [];\n        }\n\n        // Get candidate documents\n        let candidates = this._getCandidateDocuments(queryTerms);\n\n        // Apply filters if specified\n        if (Object.keys(filters).length > 0) {\n            candidates = this._applyFilters(candidates, filters);\n        }\n\n        if (candidates.size === 0) {\n            return [];\n        }\n\n        // Calculate TF-IDF scores\n        const results = [];\n        for (const docId of candidates) {\n            let score = this._calculateTfIdfScore(docId, queryTerms);\n\n            // Apply legal-specific boosts\n            score = this._applyLegalBoosts(docId, score);\n\n            // Generate snippet\n            const snippet = this._generateSnippet(docId, queryTerms);\n\n            const result = new SearchResult(\n                docId,\n                score,\n                queryTerms,\n                snippet\n            );\n            results.push(result);\n        }\n\n        // Sort by score and return top results\n        results.sort((a, b) => b.score - a.score);\n        return results.slice(0, maxResults);\n    }\n\n    /**\n     * Perform boolean search with AND, OR, NOT operators.\n     * @param {string} query - Boolean query\n     * @returns {Set<string>} Set of matching document IDs\n     */\n    booleanSearch(query) {\n        // Simple boolean query parser\n        if (query.includes(' AND ')) {\n            const terms = query.split(' AND ').map(term => term.trim().toLowerCase());\n            const resultSets = terms.map(term => this._getDocumentsForTerm(term));\n            return resultSets.length > 0 ? this._intersectSets(resultSets) : new Set();\n        }\n\n        if (query.includes(' OR ')) {\n            const terms = query.split(' OR ').map(term => term.trim().toLowerCase());\n            const resultSet = new Set();\n            for (const term of terms) {\n                const termDocs = this._getDocumentsForTerm(term);\n                termDocs.forEach(docId => resultSet.add(docId));\n            }\n            return resultSet;\n        }\n\n        if (query.includes(' NOT ')) {\n            const parts = query.split(' NOT ');\n            if (parts.length === 2) {\n                const positiveDocs = this._getDocumentsForTerm(parts[0].trim().toLowerCase());\n                const negativeDocs = this._getDocumentsForTerm(parts[1].trim().toLowerCase());\n                return this._subtractSets(positiveDocs, negativeDocs);\n            }\n        }\n\n        // Single term\n        return this._getDocumentsForTerm(query.toLowerCase());\n    }\n\n    /**\n     * Search for exact phrases.\n     * @param {string} phrase - Phrase to search for\n     * @returns {string[]} Array of matching document IDs\n     */\n    phraseSearch(phrase) {\n        let phraseTerms = this._tokenize(phrase.toLowerCase());\n        phraseTerms = phraseTerms.filter(term => !this.stopwords.has(term));\n\n        if (phraseTerms.length < 2) {\n            const singleTerm = phraseTerms[0];\n            return singleTerm ? Array.from(this._getDocumentsForTerm(singleTerm)) : [];\n        }\n\n        // Get documents containing all terms\n        let candidateDocs = this._getDocumentsForTerm(phraseTerms[0]);\n        for (let i = 1; i < phraseTerms.length; i++) {\n            const termDocs = this._getDocumentsForTerm(phraseTerms[i]);\n            candidateDocs = this._intersectSets([candidateDocs, termDocs]);\n        }\n\n        // Check phrase positions in candidates\n        const matchingDocs = [];\n        for (const docId of candidateDocs) {\n            if (this._containsPhrase(docId, phraseTerms)) {\n                matchingDocs.push(docId);\n            }\n        }\n\n        return matchingDocs;\n    }\n\n    /**\n     * Get term suggestions for auto-completion.\n     * @param {string} partialTerm - Partial term to complete\n     * @param {number} maxSuggestions - Maximum suggestions to return\n     * @returns {string[]} Array of suggested terms\n     */\n    getSuggestions(partialTerm, maxSuggestions = 10) {\n        const partialLower = partialTerm.toLowerCase();\n        const suggestions = [];\n\n        for (const term of this.termIndex.keys()) {\n            if (term.startsWith(partialLower)) {\n                // Score by frequency\n                const docFreq = this.documentFrequencies.get(term) || 0;\n                suggestions.push({ term, frequency: docFreq });\n            }\n        }\n\n        // Sort by frequency and return top suggestions\n        suggestions.sort((a, b) => b.frequency - a.frequency);\n        return suggestions.slice(0, maxSuggestions).map(s => s.term);\n    }\n\n    /**\n     * Get detailed statistics for a specific term.\n     * @param {string} term - Term to analyze\n     * @returns {Object} Term statistics\n     */\n    getTermStatistics(term) {\n        if (!this.termIndex.has(term)) {\n            return {};\n        }\n\n        const postings = this.termIndex.get(term);\n        const totalFreq = postings.reduce((sum, p) => sum + p.termFrequency, 0);\n        const docFreq = postings.length;\n\n        return {\n            term,\n            documentFrequency: docFreq,\n            totalFrequency: totalFreq,\n            idf: docFreq > 0 ? Math.log(this.totalDocuments / docFreq) : 0,\n            averageTf: docFreq > 0 ? totalFreq / docFreq : 0,\n            documents: postings.map(p => p.documentId)\n        };\n    }\n\n    /**\n     * Get comprehensive index statistics.\n     * @returns {Object} Index statistics\n     */\n    getIndexStatistics() {\n        const totalWords = Array.from(this.documents.values())\n            .reduce((sum, doc) => sum + doc.length, 0);\n\n        return {\n            documents: this.totalDocuments,\n            uniqueTerms: this.termIndex.size,\n            averageDocLength: this.totalDocuments > 0 ? totalWords / this.totalDocuments : 0,\n            mostFrequentTerms: this._getMostFrequentTerms(10)\n        };\n    }\n\n    /**\n     * Tokenize text into terms.\n     * @param {string} text - Text to tokenize\n     * @returns {string[]} Array of tokens\n     */\n    _tokenize(text) {\n        // Basic tokenization for legal text\n        const cleanText = text.replace(/[^\\w\\s]/g, ' ').toLowerCase();\n        return cleanText.split(/\\s+/).filter(token => token.length > 0);\n    }\n\n    /**\n     * Get documents containing any of the query terms.\n     * @param {string[]} terms - Query terms\n     * @returns {Set<string>} Set of candidate document IDs\n     */\n    _getCandidateDocuments(terms) {\n        const candidates = new Set();\n        for (const term of terms) {\n            if (this.termIndex.has(term)) {\n                for (const posting of this.termIndex.get(term)) {\n                    candidates.add(posting.documentId);\n                }\n            }\n        }\n        return candidates;\n    }\n\n    /**\n     * Apply metadata filters to candidate documents.\n     * @param {Set<string>} candidates - Candidate document IDs\n     * @param {Object} filters - Filter criteria\n     * @returns {Set<string>} Filtered document IDs\n     */\n    _applyFilters(candidates, filters) {\n        const filtered = new Set();\n        for (const docId of candidates) {\n            const docMetadata = this.documents.get(docId).metadata;\n\n            // Apply court filter\n            if (filters.court && docMetadata.court !== filters.court) {\n                continue;\n            }\n\n            // Apply date range filter\n            if (filters.dateFrom || filters.dateTo) {\n                const docDate = docMetadata.date;\n                if (!docDate) {\n                    continue;\n                }\n\n                if (filters.dateFrom && docDate < filters.dateFrom) {\n                    continue;\n                }\n                if (filters.dateTo && docDate > filters.dateTo) {\n                    continue;\n                }\n            }\n\n            filtered.add(docId);\n        }\n\n        return filtered;\n    }\n\n    /**\n     * Calculate TF-IDF score for a document given query terms.\n     * @param {string} docId - Document ID\n     * @param {string[]} queryTerms - Query terms\n     * @returns {number} TF-IDF score\n     */\n    _calculateTfIdfScore(docId, queryTerms) {\n        let score = 0.0;\n        const docLength = this.documents.get(docId).length;\n\n        for (const term of queryTerms) {\n            if (this.termIndex.has(term)) {\n                // Find posting for this document\n                const postings = this.termIndex.get(term);\n                const posting = postings.find(p => p.documentId === docId);\n\n                if (posting) {\n                    // TF component (normalized)\n                    const tf = docLength > 0 ? posting.termFrequency / docLength : 0;\n\n                    // IDF component\n                    const df = this.documentFrequencies.get(term) || 0;\n                    const idf = df > 0 ? Math.log(this.totalDocuments / df) : 0;\n\n                    // TF-IDF score\n                    score += tf * idf;\n                }\n            }\n        }\n\n        return score;\n    }\n\n    /**\n     * Apply legal-specific scoring boosts.\n     * @param {string} docId - Document ID\n     * @param {number} baseScore - Base score\n     * @returns {number} Boosted score\n     */\n    _applyLegalBoosts(docId, baseScore) {\n        const metadata = this.documents.get(docId).metadata;\n        let boost = 1.0;\n\n        // Court hierarchy boost\n        const court = metadata.court || '';\n        if (court in this.courtWeights) {\n            boost *= this.courtWeights[court];\n        }\n\n        return baseScore * boost;\n    }\n\n    /**\n     * Generate search snippet.\n     * @param {string} docId - Document ID\n     * @param {string[]} queryTerms - Query terms\n     * @param {number} snippetLength - Snippet length\n     * @returns {string} Generated snippet\n     */\n    _generateSnippet(docId, queryTerms, snippetLength = 200) {\n        const content = this.documents.get(docId).content;\n\n        // Simple snippet generation - find first occurrence of query term\n        for (const term of queryTerms) {\n            const start = content.toLowerCase().indexOf(term);\n            if (start !== -1) {\n                const snippetStart = Math.max(0, start - 50);\n                const snippetEnd = Math.min(content.length, start + snippetLength);\n                return content.substring(snippetStart, snippetEnd).trim();\n            }\n        }\n\n        // Fallback to beginning of document\n        return content.substring(0, snippetLength).trim();\n    }\n\n    /**\n     * Get set of document IDs containing a term.\n     * @param {string} term - Search term\n     * @returns {Set<string>} Set of document IDs\n     */\n    _getDocumentsForTerm(term) {\n        if (this.termIndex.has(term)) {\n            return new Set(this.termIndex.get(term).map(posting => posting.documentId));\n        }\n        return new Set();\n    }\n\n    /**\n     * Check if document contains phrase in order.\n     * @param {string} docId - Document ID\n     * @param {string[]} phraseTerms - Phrase terms\n     * @returns {boolean} True if phrase found\n     */\n    _containsPhrase(docId, phraseTerms) {\n        // Get positions for all terms\n        const termPositions = new Map();\n        for (const term of phraseTerms) {\n            if (this.termIndex.has(term)) {\n                const postings = this.termIndex.get(term);\n                const posting = postings.find(p => p.documentId === docId);\n                if (posting) {\n                    termPositions.set(term, posting.positions);\n                }\n            }\n        }\n\n        // Check if all terms found\n        if (termPositions.size !== phraseTerms.length) {\n            return false;\n        }\n\n        // Check if terms appear in sequence\n        const firstTermPositions = termPositions.get(phraseTerms[0]);\n\n        for (const startPos of firstTermPositions) {\n            let validPhrase = true;\n            let currentPos = startPos;\n\n            for (let i = 1; i < phraseTerms.length; i++) {\n                const termPosList = termPositions.get(phraseTerms[i]);\n                const expectedPos = currentPos + 1;\n\n                if (termPosList.includes(expectedPos)) {\n                    currentPos = expectedPos;\n                } else {\n                    validPhrase = false;\n                    break;\n                }\n            }\n\n            if (validPhrase) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the n most frequent terms in the index.\n     * @param {number} n - Number of terms to return\n     * @returns {Array} Array of [term, frequency] pairs\n     */\n    _getMostFrequentTerms(n) {\n        const termFreqs = Array.from(this.termIndex.keys()).map(term => [\n            term,\n            this.documentFrequencies.get(term) || 0\n        ]);\n        termFreqs.sort((a, b) => b[1] - a[1]);\n        return termFreqs.slice(0, n);\n    }\n\n    /**\n     * Intersect multiple sets.\n     * @param {Set[]} sets - Array of sets\n     * @returns {Set} Intersection of all sets\n     */\n    _intersectSets(sets) {\n        if (sets.length === 0) {\n            return new Set();\n        }\n\n        let result = new Set(sets[0]);\n        for (let i = 1; i < sets.length; i++) {\n            result = new Set([...result].filter(item => sets[i].has(item)));\n        }\n        return result;\n    }\n\n    /**\n     * Subtract one set from another.\n     * @param {Set} setA - Set to subtract from\n     * @param {Set} setB - Set to subtract\n     * @returns {Set} Set A minus set B\n     */\n    _subtractSets(setA, setB) {\n        return new Set([...setA].filter(item => !setB.has(item)));\n    }\n}\n\n/**\n * Demonstrate inverted index with UK legal documents\n */\nfunction demonstrateInvertedIndex() {\n    console.log('=== Inverted Index for Legal Documents Demo ===\\n');\n\n    // Sample UK legal documents\n    const documents = {\n        'uksc_2023_15': {\n            content: 'This Supreme Court case concerns constitutional law and parliamentary sovereignty. The principles established in previous Supreme Court decisions are fundamental to our constitutional framework.',\n            metadata: {\n                citation: '[2023] UKSC 15',\n                court: 'UKSC',\n                date: '2023-05-15',\n                caseName: 'R (Miller) v Prime Minister'\n            }\n        },\n        'ewca_2023_892': {\n            content: 'The Court of Appeal considered administrative law principles and judicial review procedures. The Wednesbury test applies to decisions of public bodies.',\n            metadata: {\n                citation: '[2023] EWCA Civ 892',\n                court: 'EWCA',\n                date: '2023-08-22',\n                caseName: 'Smith v Secretary of State'\n            }\n        },\n        'ewhc_2023_1456': {\n            content: 'This High Court case examined statutory interpretation principles and parliamentary intent. Administrative law requires compliance with procedural fairness.',\n            metadata: {\n                citation: '[2023] EWHC 1456 (Admin)',\n                court: 'EWHC',\n                date: '2023-06-30',\n                caseName: 'Jones v Local Authority'\n            }\n        }\n    };\n\n    // 1. Build Index\n    console.log('1. BUILDING INVERTED INDEX:');\n    const index = new InvertedIndex();\n\n    Object.entries(documents).forEach(([docId, docData]) => {\n        index.addDocument(docId, docData.content, docData.metadata);\n        console.log(`   Indexed: ${docData.metadata.caseName}`);\n    });\n\n    // 2. Basic Search\n    console.log(`\\n2. BASIC SEARCH QUERIES:`);\n    const queries = ['constitutional law', 'administrative law', 'Supreme Court'];\n\n    queries.forEach(query => {\n        const results = index.search(query, 3);\n        console.log(`\\n   Query: '${query}' (${results.length} results)`);\n        results.forEach((result, i) => {\n            const docMeta = documents[result.documentId].metadata;\n            console.log(`     ${i + 1}. ${docMeta.caseName} (Score: ${result.score.toFixed(3)})`);\n            console.log(`        Snippet: ${result.snippet.substring(0, 60)}...`);\n        });\n    });\n\n    // 3. Boolean Search\n    console.log(`\\n3. BOOLEAN SEARCH:`);\n    const booleanQueries = ['constitutional AND law', 'administrative OR Supreme'];\n\n    booleanQueries.forEach(query => {\n        const results = index.booleanSearch(query);\n        console.log(`\\n   Boolean Query: '${query}' (${results.size} documents)`);\n        Array.from(results).slice(0, 2).forEach(docId => {\n            const caseName = documents[docId].metadata.caseName;\n            console.log(`     - ${caseName}`);\n        });\n    });\n\n    // 4. Phrase Search\n    console.log(`\\n4. PHRASE SEARCH:`);\n    const phraseResults = index.phraseSearch('constitutional law');\n    console.log(`   Phrase: 'constitutional law' (${phraseResults.length} documents)`);\n    phraseResults.forEach(docId => {\n        const caseName = documents[docId].metadata.caseName;\n        console.log(`     - ${caseName}`);\n    });\n\n    // 5. Auto-completion\n    console.log(`\\n5. AUTO-COMPLETION:`);\n    const suggestions = index.getSuggestions('const', 3);\n    console.log(`   'const*': ${suggestions.join(', ')}`);\n\n    // 6. Term Statistics\n    console.log(`\\n6. TERM STATISTICS:`);\n    const stats = index.getTermStatistics('law');\n    if (Object.keys(stats).length > 0) {\n        console.log(`   'law':`);\n        console.log(`     Document frequency: ${stats.documentFrequency}`);\n        console.log(`     IDF score: ${stats.idf.toFixed(3)}`);\n    }\n\n    // 7. Index Statistics\n    console.log(`\\n7. INDEX STATISTICS:`);\n    const indexStats = index.getIndexStatistics();\n    console.log(`   Total documents: ${indexStats.documents}`);\n    console.log(`   Unique terms: ${indexStats.uniqueTerms}`);\n    console.log(`   Most frequent terms: ${indexStats.mostFrequentTerms.slice(0, 3).map(([term, freq]) => `${term}(${freq})`).join(', ')}`);\n\n    return { index, documents, statistics: indexStats };\n}\n\n// Export classes and functions for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = {\n        PostingListEntry,\n        SearchResult,\n        InvertedIndex,\n        demonstrateInvertedIndex\n    };\n}\n\n// Run demonstration if this file is executed directly\nif (typeof require !== 'undefined' && require.main === module) {\n    demonstrateInvertedIndex();\n}"